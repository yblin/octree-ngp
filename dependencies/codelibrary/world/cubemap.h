//
// Copyright 2021-2023 Yangbin Lin. All Rights Reserved.
//
// Author: yblin@jmu.edu.cn (Yangbin Lin)
//
// This file is part of the Code Library.
//

#ifndef CODELIBRARY_WORLD_CUBEMAP_H_
#define CODELIBRARY_WORLD_CUBEMAP_H_

#include "codelibrary/image/image.h"
#include "codelibrary/opengl/framebuffer.h"
#include "codelibrary/opengl/shader_factory.h"
#include "codelibrary/opengl/texture.h"
#include "codelibrary/world/kernel/render_object.h"
#include "codelibrary/world/no_lighting_node.h"
#include "codelibrary/world/primitive/cube.h"

namespace cl {
namespace world {

/**
 * Cube mapping is a method of environment mapping that uses the six faces of a
 * cube as the map shape. The environment is projected onto the sides of a cube
 * and unfolded into six regions of a single texture.
 *
 * The cube map is generated by first rendering the scene six times from a
 * viewpoint, with the views defined by a 90 degree view frustum representing
 * each cube face.
 *
 * Note that, cubemap is a special node that is not affected by operations such
 * as scaling and translation.
 */
class Cubemap : public NoLightingNode {
    friend class Sky;

public:
    /**
     * Construct an empty cubemap.
     */
    explicit Cubemap(const std::string& name = "Cubemap")
        : NoLightingNode(name) {
        Initialize();
    }

    /**
     * Construct a cubemap with the given resolution.
     */
    Cubemap(int resolution, bool mipmap = false)
        : NoLightingNode("Cubemap"), resolution_(resolution) {
        Initialize();
        Reset(resolution, mipmap);
    }

    virtual ~Cubemap() {
        if (glIsTexture(texture_id_)) {
            glDeleteTextures(1, &texture_id_);
            texture_id_ = 0;
        }
    }

    /**
     * Reset the resolution and texture of the cubemap.
     */
    void Reset(int resolution, bool mipmap = false) {
        CHECK(resolution >= 0);

        if (resolution != resolution_) {
            resolution_ = resolution;

            glBindTexture(GL_TEXTURE_CUBE_MAP, texture_id_);
            for (int i = 0; i < 6; ++i) {
                glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB16F,
                             resolution_, resolution_, 0, GL_RGB, GL_FLOAT,
                             nullptr);
            }
            glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S,
                            GL_CLAMP_TO_EDGE);
            glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T,
                            GL_CLAMP_TO_EDGE);
            glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R,
                            GL_CLAMP_TO_EDGE);
            glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER,
                            GL_LINEAR);
            glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER,
                            GL_LINEAR);
        }

        if (mipmap) {
            glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER,
                            GL_LINEAR_MIPMAP_LINEAR);
            glGenerateMipmap(GL_TEXTURE_CUBE_MAP);
        }
    }

    /**
     * Load panoramic HDR image as the cubemap.
     */
    bool LoadPanoramicHDR(const std::string& name, int resolution,
                          bool mipmap = false) {
        CHECK(resolution > 0);

        // The texture should be flipped.
        ImageF image(name, true);
        if (image.empty()) return false;
        gl::Texture texture(image);
        this->Reset(resolution, mipmap);

        texture.Bind(0);

        if (!hdr_loader_shader_) InitializeHDRLoaderShader();
        hdr_loader_shader_->Use();
        hdr_loader_shader_->SetUniform("equirectangular_map", 0);

        SetTexture(hdr_loader_shader_, mipmap);
        return true;
    }

    /**
     * Bind this cubemap to OpenGL texture unit.
     */
    void Bind(int unit) const {
        CHECK(unit >= 0);
        CHECK(unit < GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        CHECK(texture_id_ != 0);

        glActiveTexture(GL_TEXTURE0 + unit);
        glBindTexture(GL_TEXTURE_CUBE_MAP, texture_id_);
    }

    /**
     * Note that Cubemap always in the camera's frustum.
     */
    virtual bool is_cullable() const override {
        return false;
    }

    GLuint texture_id() const { return texture_id_; }
    int resolution()    const { return resolution_; }

private:
    /**
     * Set the texture of cubemap with the given shader.
     */
    void SetTexture(gl::Shader* shader, bool mipmap = false) {
        CHECK(shader);

        glEnable(GL_DEPTH_TEST);
        // Set depth function to less than and equal for skybox depth trick.
        glDepthFunc(GL_LEQUAL);
        // Enable seamless cubemap sampling for lower mip levels in the
        // pre-filter map.
        glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);

        // Setup cubemap texture.
        gl::Framebuffer framebuffer(resolution_, resolution_);
        framebuffer.Bind();

        GLint v[4];
        glGetIntegerv(GL_VIEWPORT, v);
        glViewport(0, 0, resolution_, resolution_);

        int projection_location = shader->GetLocation("projection");
        int view_location = shader->GetLocation("view");

        shader->Use();
        shader->SetUniform("model", gl::Transform());
        for (int i = 0; i < 6; ++i) {
            shader->SetUniform(projection_location, cameras_[i].projection());
            shader->SetUniform(view_location, cameras_[i].viewing());

            framebuffer.AttachColorTexture(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,
                                           texture_id_);

            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

            // Render cube.
            cube_.Render();
        }

        if (mipmap) {
            // Let OpenGL generate mipmaps from first mip face (combatting
            // visible dots artifact).
            glBindTexture(GL_TEXTURE_CUBE_MAP, texture_id_);
            glGenerateMipmap(GL_TEXTURE_CUBE_MAP);
        }

        glViewport(v[0], v[1], v[2], v[3]);
    }

    /**
     * Initialize the cubemap. It is only called once.
     */
    void Initialize() {
        FPoint3D c(0.0f, 0.0f, 0.0f);
        cameras_[0] = gl::Camera(c, { 1.0f, 0.0f,  0.0f}, {0.0f, -1.0f,  0.0f});
        cameras_[1] = gl::Camera(c, {-1.0f, 0.0f,  0.0f}, {0.0f, -1.0f,  0.0f});
        cameras_[2] = gl::Camera(c, { 0.0f, 1.0f,  0.0f}, {0.0f,  0.0f,  1.0f});
        cameras_[3] = gl::Camera(c, { 0.0f, -1.0f, 0.0f}, {0.0f,  0.0f, -1.0f});
        cameras_[4] = gl::Camera(c, { 0.0f, 0.0f,  1.0f}, {0.0f, -1.0f,  0.0f});
        cameras_[5] = gl::Camera(c, { 0.0f, 0.0f, -1.0f}, {0.0f, -1.0f,  0.0f});

        for (int i = 0; i < 6; ++i) {
            cameras_[i].SetPerspectiveModel(90.0f, 1.0f, 0.1f, 10.0f);
        }

        glGenTextures(1, &texture_id_);
        cube_.SetRenderData(Cube());
        this->AddRenderObject(&cube_);
    }

    /**
     * Setup the shader.
     */
    virtual void InitializeShader() override {
        static std::string vertex_shader = GLSL_SOURCE(
            layout (location = 0) in vec3 pos;

            uniform mat4 view;
            uniform mat4 projection;

            out vec3 texcoord;

            void main() {
                texcoord = pos;

                // Remove translation from the matrix.
                mat4 view_trim = mat4(mat3(view));
                vec4 clip = projection * view_trim * vec4(pos, 1);
                gl_Position = clip.xyww;
            }
        );

        static std::string fragment_shader = GLSL_SOURCE(
            in vec3 texcoord;
            layout (location = 0) out vec4 out_color;

            uniform samplerCube cubemap;

            void main() {
                out_color = texture(cubemap, texcoord);
            }
        );

        shader_ = GL_CREATE_SHADER(vertex_shader, fragment_shader);
    }

    virtual void SetShaderParameters(const gl::Camera &camera) override {
        this->Bind(0);
        shader_->Use();
        shader_->SetUniform("cubemap", 0);
        shader_->SetUniform("view", camera.viewing());
        shader_->SetUniform("projection", camera.projection());
    }

    /**
     * Setup HDR loader shader.
     */
    void InitializeHDRLoaderShader() {
        static std::string vertex_shader = GLSL_SOURCE(
            layout (location = 0) in vec3 pos;

            out vec3 world_pos;

            uniform mat4 projection;
            uniform mat4 view;

            void main() {
                world_pos = pos;
                gl_Position =  projection * view * vec4(world_pos, 1.0);
            }
        );

        static std::string fragment_shader = GLSL_SOURCE(
            out vec4 out_color;
            in vec3 world_pos;

            uniform sampler2D equirectangular_map;

            vec2 SampleSphericalMap(vec3 v) {
                vec2 uv = vec2(atan(v.y, v.x), asin(v.z));
                uv *= vec2(0.1591, 0.3183);
                uv += 0.5;
                return uv;
            }

            void main() {
                vec2 uv = SampleSphericalMap(normalize(world_pos));
                vec3 color = texture(equirectangular_map, uv).rgb;

                out_color = vec4(color, 1.0);
            }
        );

        hdr_loader_shader_ = GL_CREATE_SHADER(vertex_shader, fragment_shader);
    }

    // The texture of the cubemap.
    GLuint texture_id_ = 0;

    // The resolution of the cubemap.
    int resolution_ = 0;

    // Cube render object.
    RenderObject cube_;

    // Camera for capturing data onto the 6 cubemap face directions.
    gl::Camera cameras_[6];

    // Shader for loading HDR image.
    gl::Shader* hdr_loader_shader_ = nullptr;
};

} // namespace gl
} // namespace cl

#endif // CODELIBRARY_WORLD_CUBEMAP_H_
