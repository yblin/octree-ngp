//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//

#ifndef CODELIBRARY_GRAPH_FLOW_SUCCESSIVE_SHORTEST_PATH_MIN_COST_FLOW_H_
#define CODELIBRARY_GRAPH_FLOW_SUCCESSIVE_SHORTEST_PATH_MIN_COST_FLOW_H_

#include <algorithm>
#include <limits>

#include "codelibrary/graph/bellman_ford_shortest_paths.h"
#include "codelibrary/graph/graph.h"

namespace cl {
namespace graph {

/**
 * Successive shortest path algorithm for minimum cost maximum flow problem.
 * It requires each edge in the graph has a reverse edge, and the capacity of
 * each reverse edge must be zero. The cost of each edge must be nonnegative,
 * and the cost of each reverse edge must be -cost.
 *
 * This code is adapted from Boost library.
 */
template <typename T>
class SuccessiveShortestPathMinCostFlow {
    using Edge = Graph::Edge;
    using ConstIterator = Graph::EdgeList::ConstIterator;
    using EdgeProperty = Graph::EdgeProperty<T>;

public:
    explicit SuccessiveShortestPathMinCostFlow(int n_vertices)
        : network_(n_vertices) {
        capacity_ = network_.AddEdgeProperty<T>("capacity", 0);
        cost_ = network_.AddEdgeProperty<T>("cost", 0);
        flow_ = network_.AddEdgeProperty<T>("flow", 0);
    }

    /**
     * Insert an edge(s, t) with capacity and cost.
     */
    void InsertEdge(int s, int t, const T& capacity, const T& cost) {
        CHECK(capacity >= 0) << "The capacity cannot be negative.";
        CHECK(cost >= 0) << "The cost of each edge cannot be negative.";

        Edge* e = network_.InsertTwoWayEdge(s, t);
        capacity_[e] = capacity;
        cost_[e] = cost;
        cost_[e->twin()] = -cost;
    }

    /**
     * Compute a flow from source to target which maximizes the flow while
     * minimizing the costs.
     */
   T ComputeFlow(int source, int target) {
        CHECK(source >= 0 && source < network_.n_vertices());
        CHECK(target >= 0 && target < network_.n_vertices());

        int n = network_.n_vertices();
        EdgeProperty residual_capacity = network_.AddEdgeProperty(0);
        for (int i = 0; i < n; ++i) {
            for (const Edge* e : network_.edges_from(i)) {
                residual_capacity[e] = capacity_[e];
            }
        }

        while (true) {
            Array<const Edge*> predecessors;
            if (!ShortestPath(source, target, residual_capacity, &predecessors))
                break;

            // Find minimum residual capacity along the augmenting path.
            T delta = std::numeric_limits<T>::max();
            const Edge* e = predecessors[target];
            int u = -1;
            do {
                delta = std::min(delta, residual_capacity[e]);
                u = e->source();
                e = predecessors[u];
            } while (u != source);

            // Push delta units of flow along the augmenting path.
            e = predecessors[target];
            do {
                residual_capacity[e] -= delta;
                residual_capacity[e->twin()] += delta;
                u = e->source();
                e = predecessors[u];
            } while (u != source);
        }

        T total_cost = 0;
        for (int i = 0; i < n; ++i) {
            for (const Edge* e : network_.edges_from(i)) {
                if (capacity_[e] > 0) {
                    flow_[e] = capacity_[e] - residual_capacity[e];
                } else {
                    flow_[e] = 0;
                }

                total_cost += cost_[e] * flow_[e];
            }
        }
        return total_cost;
    }

    const Graph& network() const {
        return network_;
    }

    const EdgeProperty& capacity() const {
        return capacity_;
    }

    const EdgeProperty& cost() const {
        return cost_;
    }

    const EdgeProperty& flow() const {
        return flow_;
    }

private:
    /**
     * Compute a path from s to t with the minimum cost.
     *
     * We adopt belleman-ford algorithm since the edge contains negative weight.
     */
    bool ShortestPath(int source, int target,
                      const EdgeProperty& residual_capacity,
                      Array<const Edge*>* predecessors) const {
        int n = network_.n_vertices();

        std::queue<int> q;
        Array<bool> in_q(n, false);
        q.push(source);
        q.push(n);
        in_q[source] = true;

        predecessors->assign(n, nullptr);
        Array<T> distances(n, 0);

        int step = 0;
        while (!q.empty()) {
            int cur = q.front();
            q.pop();
            in_q[cur] = false;

            if (cur == n) {
                if (step++ > n) break;
                q.push(n);
                continue;
            }

            // Relax edges.
            for (const Edge* e : network_.edges_from(cur)) {
                if (residual_capacity[e] <= 0) continue;
                if (e->target() == source || e->source() == e->target())
                    continue;

                const T& w = cost_[e];
                if ((*predecessors)[e->target()] == nullptr ||
                    distances[cur] + w < distances[e->target()]) {
                    distances[e->target()] = distances[cur] + w;
                    (*predecessors)[e->target()] = e;
                    if (!in_q[e->target()]) {
                        in_q[e->target()] = true;
                        q.push(e->target());
                    }
                }
            }
        }

        return (*predecessors)[target] != nullptr;
    }

    Graph network_;         // Net flow graph.
    EdgeProperty capacity_; // The capacity of each edge.
    EdgeProperty cost_;     // The cost of each edge.
    EdgeProperty flow_;     // The flow of each edge.
};

} // namespace graph
} // namespace cl

#endif // CODELIBRARY_GRAPH_FLOW_SUCCESSIVE_SHORTEST_PATH_MIN_COST_FLOW_H_
